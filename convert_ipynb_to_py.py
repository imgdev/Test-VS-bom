from __future__ import annotations

import sys
from pathlib import Path
from typing import Iterable

import nbformat
from nbconvert import PythonExporter
from nbconvert.preprocessors import Preprocessor

MAGIC_PREFIXES = ("%", "!", "?", "%%")


class StripMagicsPreprocessor(Preprocessor):
    """
    nbconvert preprocessor that comments out IPython magics and shell escapes
    so the converted script is runnable under plain python.
    """

    def preprocess_cell(self, cell, resources, index):
        if getattr(cell, "cell_type", None) == "code" and cell.source:
            lines = cell.source.splitlines()
            new_lines = []
            for line in lines:
                stripped = line.lstrip()
                if stripped.startswith(MAGIC_PREFIXES):
                    # comment out magic / shell / introspection
                    new_lines.append("# " + line)
                else:
                    new_lines.append(line)
            cell.source = "\n".join(new_lines)
        return cell, resources


HEADER = """\
# auto-generated from ipynb by convert_ipynb_to_py.py
# do not edit this file by hand; edit the notebook instead.

try:
    # if IPython is available (eg in notebooks or rich REPLs),
    # use its display and get_ipython implementations.
    from IPython import get_ipython  # type: ignore
    from IPython.display import display  # type: ignore
except Exception:  # pragma: no cover
    # minimal fallbacks so notebooks that call `display()` don't crash
    def get_ipython():
        return None

    def display(*objs, **kwargs):
        for obj in objs:
            print(obj)
"""


def find_notebooks(root: Path) -> Iterable[Path]:
    for path in root.rglob("*.ipynb"):
        if ".ipynb_checkpoints" in path.parts:
            continue
        yield path


def convert_one(path: Path, out_dir: Path | None = None) -> Path:
    nb = nbformat.read(path, as_version=4)
    exporter = PythonExporter()
    exporter.register_preprocessor(StripMagicsPreprocessor, enabled=True)
    body, _ = exporter.from_notebook_node(nb)

    # prepend compat header so display/get_ipython won't explode
    body = HEADER + "\n\n" + body

    target_dir = out_dir or path.parent
    target = target_dir / (path.stem + ".py")
    target.write_text(body, encoding="utf-8")
    return target


def main(argv: list[str] | None = None) -> int:
    argv = argv or sys.argv[1:]
    root = Path(argv[0]).resolve() if argv else Path(".").resolve()
    if root.is_file():
        notebooks = [root]
        base_dir = root.parent
    else:
        notebooks = list(find_notebooks(root))
        base_dir = root

    if not notebooks:
        print(f"no .ipynb files found under {root}", file=sys.stderr)
        return 1

    for nb_path in notebooks:
        out_path = convert_one(nb_path)
        rel_nb = nb_path.relative_to(base_dir)
        rel_py = out_path.relative_to(base_dir)
        print(f"[ipynb->py] {rel_nb} -> {rel_py}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
